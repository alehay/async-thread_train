
co_await. Унарный оператор, 
позволяющий, в общем случае, приостановить выполнение сопрограммы
 и передать управление вызывающей стороне,
пока не завершатся вычисления представленные операндом;

co_yield. Унарный оператор, 
частный случай оператора co_await, позволяющий приостановить выполнение 
сопрограммы и передать управление и значение операнда вызывающей стороне;

co_return. Оператор завершает работу сопрограммы, 
возвращая значение, после вызова сопрограмма 
больше не сможет возобновить свое выполнение.


+++++++++++++++++++++++++++++++++ Promise +++++++++++++++++++++++++++++++++

Объект типа Promise позволяет настраивать поведения сопрограммы как программной единицы. Должен определять:

- Поведение сопрограммы при первом вызове;
- ПОведение при выходе из сопрограммы
- Стратегию обработки исключительных ситуаций 
- уточнение типа выражения операторов co_await
- Передача промежуточных и конечных результатов выполнения вызывающей стороне.
Так же promise_type учавствует в разрешении перегрузки операторов new delete
что позволяет настраивать динамическое размещение фрейма сопрограммы.

Объект promise_type создается и хранится в рамках фрейма сопрограмы для каждого 
нового вызова. 


Тип Promise определяется компилятором согласно специализации шаблона std::coroutine_traits 
по типу сопрограммы, в специализации участвует: тип возвращаемого значения, 
список типов входных параметров, тип класса, если сопрограмма представлена методом. 
Шаблон std::coroutine_traits определен следующем образом:

template <typename Ret, typename = std::void_t< >>
struct coroutine_traits_base
{};

template <typename Ret>
struct coroutine_traits_base<Ret, std::void_t<typename Ret::promise_type>>
{
    using promise_type = typename Ret::promise_type;
};

template <typename Ret, typename... Ts>
struct coroutine_traits : coroutine_traits_base<Ret>
{};


Тип должен иметь строгое имя promise_type.
 Из определения std::coroutine_traits, следует что существует 
как минимум одна специализация, которая ищет определение 
типа promise_type в пространстве имен типа возвращаемого результата.
promise_type может быть как именем типа, так и псевдонимом.


Пример простого определния promise_type
struct Task
{
    struct Promise
    {
        ...
    };
    using promise_type = Promise;
};
...

Task foo()
{
    ...
}


Также определение подобного типа Task полезно в более сложных ситуациях,
 тип может определять дополнительную семантику внешнего оперирования сопрограммой:
 передавать и получать данные, передавать поток управления (пробуждать) 
 или уничтожать сопрограмму.


 Другой спрособ определить promise_type -  это явно специализировать шаблон
 std::coroutine_traits. Для сопрограмм представленных методом пользоваетльского типа

code:
 Class Coroutine {
     public:
        void call(int);
 };

 namespase std;
 {
     template <>
     struct coroutine_traits <void, Coroutine, int>
     {
         using promise_type = Coroutine;
     };
 }

Если promise_type имеет конструткор соответсвующий параметрам сопрограммы, то он бует вызван,
иначе будет вызван конструктор по умолчанию. Важно, что все аргументы будут переданы как Lvalues,
это нужно для того чтобы мы не смогли случано переместить данные из переданных аргументов в обхект 
Promise т.к. мы ожидаем агруметы в теле сопрограммы. 


 +++++++++++++++++++++++ Awaitable ++++++++++++++++++++++++++
прежде чем определить интерфейс типа Promise 
необходимо описать Awaitable.


Объекты типа Awaitable определяют семантику потока управления сопрограммы. Позволяют:

-Определить, следует ли приостанавливать выполнение сопрограммы 
в точке вызова оператора co_await;
    
-Выполнить некоторую логику после приостановления выполнения сопрограммы 
для дальнейшего планирования возобновления ее работы (асинхронные операции);

-Получить результат вызова оператора co_await, после возобновления работы.


объект типа Awaitable определяется в результате разрешения перегрузки и вызова оператора co_await
Если жизнеспособной перегрузки не было найдено, то результат вычисления самого операнда является 
объектом типа Awaitable. Далее вызов оператора транслируется в последовательность вызовов 
методов объекта данного типа. 

Например мезанизм отложенного выполеия, который позволит функции уснуть на некоторое
время, вернет управление вызывающей стороне, послее чего продолджить свое выполнение 

Task foo()
{
    using namespace std::chrono_literals;

    // выполнить некоторый набор операций
    // вернуть управление
    co_await 10s;
    // через 10 секунд выполнить еще один набор операций.
}

В примере выражение переданное в качестве операнда имеет тип std::chrono::duration<long long>
что бы приведенный код компилировался нужно определить перегрузку оператора co_await 
для выраженя такого типа. 

template<typename Rep, typename Period>
auto operator co_await(std::chrono::duration<Rep, Period> duration) noexcept
{
    struct Awaitable
    {
        explicit Awaitable(std::chrono::system_clock::duration<Rep, Period> duration)
            : duration_(duration)
        {}

        ...

    private:

        std::chrono::system_clock::duration duration_;
    };

    return Awaitable{ duration };
}


Внутри перегрузки мы описываем тип Awaitable,  задача котого запланировать и вернуть управление 
сопрограмме через заданный промежуток времени, и возращаемый объект данного типа как результат

НАм осталось определить интерфейс типа Awaitable , чтобы это сделать рассмотрим подробнее 
вызов оператора co_await <expr> и код, который комилятор генерирует в месте вызова. 


{
    // в начале мы определили тип Promise
    using coroutine_traits = std::coroutine_traits<ReturnValue, Args...>;
    using promise_type = typename coroutine_traits::promise_type;

    ...
    // вызов co_await <expr> в рамках сопрограммы

    // 1.
    // Создаем объект типа Awaitable, находим подходящую перегрузку оператора co_await,
    // результат сохраняем во фрейме сопрограммы (как создается фрейм мы рассмотрим
    // в рамках описания типа Promise), это необходимо 
    // т.к. с помощью Awaitable мы вернем результат вычисления, после возобновления работы.
    
    frame->awaitable = create_awaitable(<expr>);

    // 2.
    // Вызываем метод await_ready().
    // Основная задача метода позволить нам избежать остановки сопрограммы
    // в случаях когда вычисления могут быть завершены синхронно
    // или уже завершены, сохранив вычислительные ресурсы.

    if (!awaitable.await_ready())
    {
        // 3.
        // Если вызов await_ready() вернул false,
        // то сопрограмма приостанавливает свое выполнение,
        // сохраняет состояние: состояние локальных переменных, точку остановки
        // (это идентификатор состояния, на которое сопрограмма перейдет
        // после возобновления своей работы, 
        // достаточная информация что бы перейти в точку <resume-point>)

        <suspend-coroutine>

        // 4.
        // Определяем тип coroutine_handle
        // corotine_handle - это дескриптор фрейма сопрограммы.
        // он обеспечивает низкоуровневую функциональность оперирования сопрограммой:
        // передача управления (возобновление выполнения) и удаление.

        using handle_type = std::coroutine_handle<promise_type>;
        using await_suspend_result_type =
            decltype(frame->awaitable.await_suspend(handle_type::from_promise(promise)));

        // 5.
        // Вызов метода await_suspend(handle), 
        // задача метода await_suspend выполнить некоторую логику
        // на клиентской стороне после приостановления выполнения сопрограммы
        // для дальнейшего планирования возобновления ее работы (если необходимо). 
        // Метод принимает один аргумент - дескриптор сопрограммы.
        // Тип возвращаемого результата, определяет семантику передачи управления

        if constexpr (std::is_void_v<await_suspend_result_type>)
        {
            // Тип возвращаемого результата void,
            // мы безусловно передаем управление вызывающей стороне
            // (под вызывающей стороной здесь понимается сторона,
            // которая передала управление сопрограмме)
            frame->awaitable.await_suspend(handle_type::from_promise(promise));
            <return-to-caller-or-resumer>;
        }
        else if constexpr (std::is_same_v<await_suspend_result_type, bool>)
        {
            // Тип возвращаемого результата bool,
            // если метод вернул false, то управление не передается вызывающей стороне
            // и сопрограмма возобновляет свое выполнение
            // Это полезно, например, когда асинхронная операция
            // инициированная объектом Awaitable завершилась синхронно
            if (frame->awaitable.await_suspend(handle_type::from_promise(promise))
                <return-to-caller-or-resumer>;
        }
        else if constexpr (is_coroutine_handle_v<await_suspend_result_type>)
        {
            // Тип возвращаемого результата std::coroutine_handle<OtherPromise>,
            // т.е. вызов возвращает дескриптор другой сопрограммы,
            // то мы передаем управление этой сопрограмме, это семантика позволяет
            // эффективно реализовывать симметричный механизм передачи потока 
            // управления между сопрограммами
            auto&& other_handle = frame->awaitable.await_suspend( 
                handle_type::from_promise(promise));
            other_handle.resume();
        }
        else
        {
            static_assert(false);
        }
    }

    // 6.
    // Точка возобновления выполнения (пробуждения)
    // Вызов метода await_resume(). Задача метода получить результат вычисления.
    // Возвращаемое значение рассматривается как результат вызова оператора co_await.
resume_point:
    return frame->awaitable.await_resume();
}




Workflow состоит из следующих стадий:

    Корутина начинает выполнение
        аллоцирование frame корутины при необходимости.
        копирование всех параметров функции в frame корутины.
        создание promise объекта promise.
        вызов promise.get_return_object() для создания handle корутины и сохранение такового в локальной переменной. Результат вызова будет возвращен вызывающей стороне при первой приостановке корутины.
        вызов promise.initial_suspend() и ожидание co_await результата. Данный тип promise обычно возвращает suspend_never для корутин немедленного выполнения или suspend_always для ленивых корутин.
        тело корутины выполняется начинает выполнение после co_await promise.initial_suspend()
    Корутины достигают точки приостановки
        возвращаемый объект promise.get_return_object() возвращается вызывающей сущности который инициирует продолжение выполнение корутины
    Корутина достигает co_return
        вызывается promise.return_void() для co_return или co_return expression, где expression имеет тип void
        вызывается promise.return_value(expression) для co_return expression, где expression имеет тип отличный от void
        удаляется весь стек созданных переменных
        вызывается promise.final_suspend() и ожидается co_await результат
    Корутина уничтожается (посредством завершения через co_return, необработанного исключения или через handle корутины)
        вызывается деструктор promise объекта
        вызывается деструктор параметров функции
        освобождается память используемая frame корутины
        передача выполнения вызывающей сущности


Когда корутина завершается посредством необработанного исключения происходит следующее:

    ловится исключение и вызывается promise.unhandled_exception() из catch блока
    вызывается promise.final_suspend() и ожидается co_await результата
